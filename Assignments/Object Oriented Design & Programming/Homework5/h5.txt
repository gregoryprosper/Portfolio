COP4331/COP5339 Homework 5

Chapter 10 and Chapter 7

*** no homeworks will be accepted after the due date ***

Preparation/Delivery Instructions:


   1. Write all your answers, in the order given in the homework file, in ONE PDF file 
      (or Word 97, with extension .doc). 
      
      Follow this format:
      Write your name followed by the section number (e.g. COP5339 003).
      For each problem write as a heading the problem number (e.g. "4.1"). 
      The problem number must be clearly readable before the problem solution. 
      Java source files must be properly identified: write the file name as a heading, 
      followed by the file content.
      Make sure Java code and UML diagrams are readable. Make it easy for the grader.
      Nice color syntax highlighting is not required, but appreciated. 
      Proper indentation and code formatting is required.
      
   2. Do *not* submit other files. Upload only the pdf/.doc file with all solutions.
   
   3. For full credit, your designs and code must follow the course guidelines and must compile without 
		warnings and work correctly, as required in the problem description. 

		Remider: it is academic misconduct to submit work that is not yours.
		Do not paste code taken from the web. Only code part of the solution will be graded.
		You can (and should) use any helpful code from the textbook for your answers.

----------------
Other general advice that will help you do well in this class. And build better code, too.

    * !! Ask your instructor if you have any questions about the homework 
	(and anything else related to the class) !!

    * Consult the solutions for selected textbook problems, available at 
		http://www.horstmann.com/oodp2/solutions/solutions.html

    * Do exactly what the problem asks you to do. There is no extra credit for unnecessary work.
      Points are deducted if design or implemenation requirements are not met.

    * Do not rename classes and methods if they are given.

    * Do not change method signature, where specified. 

    * Design/code your classes for general use. Assume there are other programmers who will use your code.

    * Avoid unnecessary side effects. Do not use static fields/methods, unless warranted (e.g. main()).

    * check for errors and exceptions.

    * Enclose methods that may throw exceptions within a try-catch block.
    
    * Check parameters and variables before you do something in a method. E.g. average = sum/list.size() 
		may throw an ArithmeticException if the list is empty. 


    * Use class (static) variables only when necessary (e.g. to share a variable between instances, 
		or for constants)

    * Do not define instance variables when local variables could do the job.

    * Use nouns for class names and verbs for methods.

    * Follow coding conventions; class names start with capitals, methods and variables start with lowercase, etc. 


Scoring: non-optional problems total = 100 points
==============================================================================================================

Homework problems (Chapter 10):

10.1
Consider the following generic queue interface:

interface MyQueue <E> {
   // return the top of the queue element or throw NoSuchElementException if empty	  
   E head();

   // remove and return the top of the queue element or throw NoSuchElementException if empty
   E dequeue();

   // add an element to the queue
   void enqueue(E e);

   // returns the size of the queue
   int size();

   // returns true if the queue is empty
   boolean isEmpty();

   // add elements to this queue from a collection c of E references:
   void addAll(Collection <? extends E> c);
}

a) Use the Adapter pattern to design a generic queue class called  LQueue<E> that implements
interface MyQueue<E> and that uses a LinkedList<E> object to stores the queue elements.
Write the class diagram for the pattern. Make sure you identify the pattern roles (e.g. "adapter",
"adaptee") with UML notes.

b) Implement class LQueue<E> in Java. 
Write correct contracts for each method. (Notice that NoSuchElementException is not a checked
exception, but you could put it in the function signature.)

c) Write a class QueueTest with a main(...) method that tests all 6 methods from class LQueue<E>.



10.2
Use the Singleton pattern for a new Java class Stdout you need to write 
that can have just one instance. A programmer can use the instance 
to print text lines (String objects) to the terminal with the method printline():

    public class Stdout {
       public void printline(String s) {
          ...   // print s to System.out
       }
       ...      // fill in the dots
    }

Make sure the pattern is implemented correctly (e.g. just one instance can be created). 
Notice that the printline() function is NOT static.

Write a main(....)  method to test your code.


10.3
a) Both the Command and Strategy patterns recommend using objects in place of methods.
How do they differ in intent ?

b) Explain why class MouseMotionAdapter is not an adapter class in the sense of the
Adapter design pattern.



--------------------------------------------------------------------------------------

Chapter 7
7.1. 
a. Implement a generic class Pair<K,V> that stores pairs of (key, value) pairs.
Usage example:
	Pair<Integer,String> p = new Pair<>(1, "one");
	System.out.println("The string value of " + p.k() + " is " + p.v());

A pair object has a constructor 

	public Pair(K k, V v) {...}

has accessors:

	public K k() {...}
	public V v() {...}

and overrides these methods inherited from class Object:
	public boolean equals(Object obj) {...}
	public int hashCode() {...}
	public String toString() {...}
	public Object clone() {...}

Your class must be immutable, serializable, and cloneable.
Follow the guidelines from the textbook when implementing the above functions.

b. Write a method PairTest class with method main() where you test:
- equality with equals()
- cloning : make a clone and compare with the original
- serialization. Serialize to an ObjectStream then load the object and compare it to the original 
  with equals().
- hashCode(). Must be compatible with equals (i.e. equal hashCode() for equal objects, and 
  different values (with high probability) for different key or/and value objects



7.2
a) Write a generic method 

      public static <...> Collection<Pair<...>> sortPairCollection(Collection <Pair<....>> col)

in a Utils class that takes as parameter a collection of Pair<K,V> objects
and returns a new collection object (use ArrayList<...>) with the pair elements from collection col
sorted in ascending order. For comparing pairs, the K type must implement Comparable<....>
Use the proper type constraints.

b) 
Write a  main() function in Utils.java that tests the sortPairCollection() with K=String and V=Integer.
a

=========================================================================================
Note: you still need to paste all code in ONE pdf file for homework submission, as before.
=========================================================================================
  




